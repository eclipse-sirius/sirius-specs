---
title: GraphQL EMF
author: Stéphane Bégaudeau
date: 2018-11-13
---

The EMF GraphQL schema will let users manipulate their models and metamodels. It should allow users to navigate inside of Ecore models and any tree of EObjects. It should also provide a way to create a GraphQL schema parameterized by an Ecore metamodels.

In this document, we will use the Java code which could be generated by the GenModel in order to describe EMF models.

## Capabilities

This API will provide the following capabilities:

- Create a GraphQL schema for any metamodel
- Manipulation of any EObject thanks to a generic GraphQL schema

## Creating a GraphQL API from a metamodel

In order to create a GraphQL schema from an Ecore metamodel we will need to define a set of transformation rules to apply to any metamodel. Those rules will have to handle some challenges since, by design, GraphQL is not object oriented while EMF is. As a result some concepts available in EMF and in Java cannot be expressed directly in GraphQL.

### EDataType

Both GraphQL and EMF come with a set of types that can be used to define the structure of the data. Those default types are not exactly the same but most of them have an equivalent. We will support in GraphQL all the default data types from EMF starting with the one which have a GraphQL equivalent.

| Ecore       | GraphQL    |
|-------------|------------|
| EBigDecimal | BigDecimal |
| EBigInteger | BigInteger |
| EBoolean    | Boolean    |
| EByte       | Byte       |
| EChar       | Char       |
| EFloat      | Float      |
| EInt        | Int        |
| ELong       | Long       |
| EShort      | Short      |
| EString     | String     |

Some EMF types do not exist by default in GraphQL, we will support them with custom GraphQL scalars.

* EByteArray
* EDate
* EDouble
* EMap

On top of that some data types are the object version of the Java primitive type. Those data types will be treated in a similar fashion as the primitive type version.

* EBooleanObject
* ECharacterObject
* EDoubleObject
* EFloatObject
* EIntegerObject
* EByteObject
* ELongObject
* EShortObject

The following data types won't be supported for now.

* EDiagnosticChain
* EFeatureMap
* EFeatureMapEntry
* EEList
* EEnumerator
* EResource
* EResourceSet
* EInvocationTargetException
* EJavaClass
* EJavaObject
* ETreeIterator


### EEnum

Each EMF enumeration will be transformed into a GraphQL enumeration containing the same enumeration literals. This transformation is quite straightforward.

<!-- prettier-ignore -->
```java
public enum Visibility {
  PUBLIC
  PROTECTED
  PRIVATE
}
```

The Java code below will be transformed to this GraphQL equivalent.

<!-- prettier-ignore -->
```graphql
enum Visibility {
  PUBLIC
  PROTECTED
  PRIVATE
}
```

### EStructural Features

The lower bound and the upper bound of the structural features will be used in order to determined if a GraphQL list should be created and if the field should be specified as mandatory. All multivalued structural features will be transformed to non-null collections of non-null elements.

### Interfaces and Abstract EClass

Each EMF interface will be tranformed into a GraphQL interface. Abstract EClasses will be handled in a similar fashion as EMF interfaces. For each field of the EMF interface, a GraphQL field will be created with the matching type.

Contrary EMF and Java (a major source of inspiration for EMF), the inheritance between interfaces is not supported currently in GraphQL. As such, for such situation, a GraphQL interface would contain all the fields of its matching interface and all its extended interfaces. Let's consider two EMF interfaces named ISuperInterface and ISubInterface respectively with ISubInterface extending ISuperInterface. Those two interfaces could be represented with the following Java code.

<!-- prettier-ignore -->
```java
public interface ISuperInterface {
  public String getName();
}

public interface ISubInterface extends ISuperInterface {
  public boolean isAvailable();
}
```

In order to convert those two interfaces to GraphQL, we will create two GraphQL interfaces with the same name. Each GraphQL interface will contain the fields matching its Java version but on top of that ISubInterface will contain all the fields of the interface it extends. Each extending interface will have all the fields of all the interface it extend all the way up to the top of the inheritance tree.

<!-- prettier-ignore -->
```graphql
interface ISuperInterface {
  name: String
}

interface ISubInterface {
  name: String
  available: Boolean
}
```

An EClass implementing the interface ISubInterface would have to be translated to a GraphQL type implementing both ISubInterface and ISuperInterface. Let's consider this example of an EClass named AnEClass implementing ISubInterface.

<!-- prettier-ignore -->
```java
public class AnEClass implements ISubInterface {
  private String name;

  private boolean available;

  public String getName() {
    return this.name;
  }

  public boolean isAvailable() {
    return this.available;
  }
}
```

This EClass woulc be transformed into a GraphQL type which would all the interfaces of the interface inheritance tree. The GraphQL type would also have to repeat all the fields of the interface it implements.

<!-- prettier-ignore -->
```graphql
type AnEClass implements ISuperInterface, ISubInterface {
  name: String
  available: Boolean
}
```

### EClass

Each EClass will be tranformed into a GraphQL type with each field converted to a GraphQL field. The interfaces implemented or the abstract class extended will be transformed as GraphQL implemented interfaces.

EClass inheritance is an unique issue with GraphQL since we both have to be able to define a type to use and a contract that can be implemented by others. As a result, in a perfect world, each EClass extended by another EClass would need to produce both a type and an interface. Let’s consider an example where an EClass named ESuperClass is extended by an EClass named ESubClass to see what the result would look like.

<!-- prettier-ignore -->
```java
public class ESuperClass {
  private String name;

  public String getName() {
    return this.name;
  }
}

public class ESubClass extends ESuperClass {
}
```

In GraphQL, such situation would force us to create both an interface ESuperClass for ESubClass to implement and a type ESuperClassImpl to represent ESuperClass intances. Both ESubClass and ESuperClassImpl would then implement ESuperClass.

<!-- prettier-ignore -->
```graphql
interface ESuperClass {
  name: String
}
type ESuperClassImpl implements ESuperClass {
  name: String
}
type ESubClass implements ESuperClass {
  name: String
}
```

While this approach will make EClass inheritance work, it comes with two problems. Firstly, the EClass has to be separated into two concepts, an interface and a type and a naming convention for those two concepts has to be determined. It should be up to the developer of the system to specify how the interface and the type will be named otherwise we may not be able to handle some naming conflits. By default, the interface will keep the name of the EClass and the type will use the suffix "Impl", a convention inspired by EMF itself.

Secondly, generating a type and an interface is cumbersome and it would be best not to do it unless explicitly required. Unfortunately, determining that an EClass is extended by another EClass would require us to look at all the EClasses of all the metamodels available. Such computation would be very expensive for now so we will start by not using such pattern unless a non-abstract and non-interface EClass is extended by another EClass in the same metamodel. Developers will be able to opt-in for this pattern programmatically to handle complex situations but this default choice will be able to handle most use cases without a massive performance penalty.

### Example with Basic Family

Using the rules defined above, we could translate the Basic Family metamodel from the Sirius samples. Here is the basic family metamodel in XML.

<!-- prettier-ignore -->
```xml
<?xml version="1.0" encoding="UTF-8"?>
<ecore:EPackage xmi:version="2.0"
                xmlns:xmi="http://www.omg.org/XMI"
                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                xmlns:ecore="http://www.eclipse.org/emf/2002/Ecore"
                name="basicfamily"
                nsURI="http://www.eclipse.org/sirius/sample/basicfamily"
                nsPrefix="basicfamily">

  <eClassifiers xsi:type="ecore:EClass"
                name="Person"
                abstract="true">

    <eStructuralFeatures xsi:type="ecore:EAttribute"
                         name="name"
                         eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>

    <eStructuralFeatures xsi:type="ecore:EReference"
                         name="children"
                         upperBound="-1"
                         eType="#//Person"
                         eOpposite="#//Person/parents"/>

    <eStructuralFeatures xsi:type="ecore:EReference"
                         name="parents"
                         upperBound="2"
                         eType="#//Person"
                         eOpposite="#//Person/children"/>

    <eStructuralFeatures xsi:type="ecore:EReference"
                         name="mother"
                         eType="#//Woman"
                         derived="true"/>

    <eStructuralFeatures xsi:type="ecore:EReference"
                         name="father"
                         eType="#//Man"
                         derived="true"/>
  </eClassifiers>

  <eClassifiers xsi:type="ecore:EClass"
                name="Family">
    <eStructuralFeatures xsi:type="ecore:EAttribute"
                         name="name"
                         eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"/>

    <eStructuralFeatures xsi:type="ecore:EReference"
                         name="members"
                         upperBound="-1"
                         eType="#//Person"
                         containment="true"/>
  </eClassifiers>

  <eClassifiers xsi:type="ecore:EClass"
                name="Man"
                eSuperTypes="#//Person"/>

  <eClassifiers xsi:type="ecore:EClass"
                name="Woman"
                eSuperTypes="#//Person"/>
</ecore:EPackage>
```

This metamodel should be transformed into the following GraphQL schema.

<!-- prettier-ignore -->
```graphql
interface Person {
  name: String
  children: [Person!]!
  parents: [Person!]!
  mother: Woman
  father: Man
}

type Family {
  name: String
  members: [Person!]!
}

type Man implements Person {
  name: String
  children: [Person!]!
  parents: [Person!]!
  mother: Woman
  father: Man
}

type Woman implements Person {
  name: String
  children: [Person!]!
  parents: [Person!]!
  mother: Woman
  father: Man
}
```

Thanks to this GraphQL schema, we could execute the following query.

<!-- prettier-ignore -->
```graphql
query findFamilyAndMembers {
  family {
    name
    members {
      name
      children {
        name
      }
      parents {
        name
        parents {
          name
        }
      }
      mother {
        name
      }
      father {
        name
      }
    }
  }
}
```

This query could return the following result.

<!-- prettier-ignore -->
```json
{
  "data": {
    "family": {
      "name": "Doe",
      "members": [
        {
          "name": "John",
          "children": [
            {
              "name": "Jane"
            }
          ],
          "parents": []
        },
        {
          "name": "Jane",
          "children": [],
          "parents": [
            {
              "name": "John",
              "parents": []
            },
          ],
          "father": {
            "name": "John"
          }
        }
      ]
    }
  }
}
```

### Example with Ecore

Transforming the Ecore metamodel would produce the following GraphQL schema

<!-- prettier-ignore -->
```graphql
interface EModelElement {
  eAnnotations: [EAnnotation!]!
}

type EAnnotation implements EModelElement {
  eAnnotations: [EAnnotation!]!
  source: String
  eModelElement: ModelElement
  contents: [EObject!]!
  references: [EObject!]!
}

interface ENamedElement {
  eAnnotations: [EAnnotation!]!
  name: String
}

type EPackage implements ENamedElement {
  nsURI: String
  nsPrefix: String
  eFactoryInstance: EFactory
  eClassifiers: [EClassifier!]!
  eSubPackages: [EPackage!]!
  eSuperPackages: [EPackage!]!
}

interface ETypedElement {
  eAnnotations: [EAnnotation!]!
  name: String
  ordered: Boolean
  unique: Boolean
  lowerBound: Int
  upperBound: Int
  many: Boolean
  required: Boolean
  eType: EClassifier
  eGenericType: EGenericType
}

interface EClassifier {
  eAnnotations: [EAnnotation!]!
  name: String
  instanceClassName: String
  instanceTypeName: String
  ePackage: EPackage
}

type EClass implements EClassifier {
  eAnnotations: [EAnnotation!]!
  name: String
  instanceClassName: String
  instanceTypeName: String
  ePackage: EPackage
  abstract: Boolean
  interface: Boolean
  eSuperTypes: [EClass!]!
  eOperations: [EOperation!]!
  eAllAttributes: [EAttribute!]!
  eAllReferences: [EReference!]!
  eReferences: [EReference!]!
  eAttributes: [EAttribute!]!
  eAllContainments: [EReference!]!
  eAllOperations: [EOperation!]!
  eAllStructuralFeatures: [EStructuralFeature!]!
  eAllSuperTypes: [EClass!]!
  eIDAttribute: EAttribute
  eStructuralFeatures: [EStructuralFeature!]!
  eAllGenericSuperTypes: [EGenericType!]!
}

interface EStructuralFeature implements ETypedElement {
  eAnnotations: [EAnnotation!]!
  name: String
  ordered: Boolean
  unique: Boolean
  lowerBound: Int
  upperBound: Int
  many: Boolean
  required: Boolean
  eType: EClassifier
  eGenericType: EGenericType
  changeable: Boolean
  volatile: Boolean
  transient: Boolean
  defaultValueLiteral: String
  unsettable: Boolean
  derived: Boolean
  eContainingClass: EClass
}

type EAttribute implements EStructuralFeature {
  eAnnotations: [EAnnotation!]!
  name: String
  ordered: Boolean
  unique: Boolean
  lowerBound: Int
  upperBound: Int
  many: Boolean
  required: Boolean
  eType: EClassifier
  eGenericType: EGenericType
  changeable: Boolean
  volatile: Boolean
  transient: Boolean
  defaultValueLiteral: String
  unsettable: Boolean
  derived: Boolean
  eContainingClass: EClass
  iD: Boolean
  eAttributeType: EDataType
}

type EReference implements EStructuralFeature {
  eAnnotations: [EAnnotation!]!
  name: String
  ordered: Boolean
  unique: Boolean
  lowerBound: Int
  upperBound: Int
  many: Boolean
  required: Boolean
  eType: EClassifier
  eGenericType: EGenericType
  changeable: Boolean
  volatile: Boolean
  transient: Boolean
  defaultValueLiteral: String
  unsettable: Boolean
  derived: Boolean
  eContainingClass: EClass
  containment: Boolean
  container: Boolean
  resolveProxies: Boolean
  eOpposite: EReference
  eReferenceType: EClass
  eKeys: [EAttribute!]!
}

type EOperation implements ETypedElement {
  eAnnotations: [EAnnotation!]!
  name: String
  ordered: Boolean
  unique: Boolean
  lowerBound: Int
  upperBound: Int
  many: Boolean
  required: Boolean
  eType: EClassifier
  eGenericType: EGenericType
  eContainingClass: EClass
  eTypeParameters: [ETypeParameter!]!
  eParameters: [EParameter!]!
  eExceptions: [EClassifier!]!
  eGenericExceptions: [EGenericType!]!
}

type EParameter implements ETypedElement {
  eAnnotations: [EAnnotation!]!
  name: String
  ordered: Boolean
  unique: Boolean
  lowerBound: Int
  upperBound: Int
  many: Boolean
  required: Boolean
  eType: EClassifier
  eGenericType: EGenericType
  eOperation: EOperation
}

interface EDataType {
  eAnnotations: [EAnnotation!]!
  name: String
  instanceClassName: String
  instanceTypeName: String
  ePackage: EPackage
  serializable: Boolean
}

type EDataTypeImpl implements EDataType {
  eAnnotations: [EAnnotation!]!
  name: String
  instanceClassName: String
  instanceTypeName: String
  ePackage: EPackage
  serializable: Boolean
}

type EEnum implements EDataType {
  eAnnotations: [EAnnotation!]!
  name: String
  instanceClassName: String
  instanceTypeName: String
  ePackage: EPackage
  serializable: Boolean
  eLiterals: [EEnumLiteral!]!
}

type EEnumLiteral implements ENamedElement {
  eAnnotations: [EAnnotation!]!
  name: String
  value: Int
  literal: String
  eEnum: EEnum
}

type EFactory implements EModelElement {
  eAnnotations: [EAnnotation!]!
  ePackage: EPackage
}

type EGenericType {
  eUpperBound: EGenericType
  eTypeArguments: [EGenericType!]!
  eLowerBound: EGenericType
  eClassifier: EClassifier
}

type ETypeParameter implements ENamedElement {
  eAnnotations: [EAnnotation!]!
  name: String
  eBounds: [EGenericType!]!
}
```

This GraphQL schema can only work if we define a GraphQL schema for EObject first. This schema will be defined manually in order to customize some details.

## Manipulating any EObject

When we will retrieve an EObject from a GraphQL schema, we will want to request some pieces of information from it. The first things consumers of the API will want to retrieve are its label and image. Developers may want to indicate that some objects are EObjects even if they already have a concrete type since in EMF everything extends EObject. Yet at the same time, some objects may be dynamic instances of EObject. To handle such situation the concept of EObject will split into both an interface and a type.

<!-- prettier-ignore -->
```graphql
interface EObject {
  label: String!
  imageURL: String!
}

type DynamicEObject implements EObject {
  label: String!
  imageURL: String!
}
```

The type DynamicEObject will be used each time an EObject that should be returned by GraphQL does not match a type in the GraphQL schema created from the rules that we have seen above. This type will contain exactly all the fields available in the interface EObject. All the concrete types created from the previous rules will implement EObject.

### From an EObject to its metamodel

In order to retrieve the metamodel of an EObject quite easily, an EObject will offer a field referencing its EClass.

<!-- prettier-ignore -->
```graphql
interface EObject {
  label: String!
  imageURL: String!
  eClass: EClass!
}
```

Using a GraphQL query, users will be able to retrieve everything needed to manipulate an EObject.

<!-- prettier-ignore -->
```graphql
query eObject {
  eObject {
    label
    imageURL
    eClass {
      name
      ePackage {
        name
      }
    }
  }
}
```

Such query could produce the following result.

<!-- prettier-ignore -->
```json
{
  "data": {
    "eObject": {
      "label": "Man - Jonn Doe",
      "imageURL": "https://localhost:8080/api/images/...",
      "eClass": {
        "name": "Man",
        "ePackage": {
          "name": "Family"
        }
      }
    }
  }
}
```

### Containment

In order to navigate inside of an EObject tree, we will have to provide the EMF containment references as GraphQL fields. For that, we will add support for the following fields inside the type EObject.

* eContents
* eContainer
* eContainingFeature
* eContainmentFeature

As a result, the type EObject will look like this.

<!-- prettier-ignore -->
```graphql
interface EObject {
  label: String!
  imageURL: String!
  eClass: EClass!
  eContents: [EObject!]!
  eContainer: EObject
  eContainingFeature: EStructuralFeature
  eContainmentFeature: EReference
}
```

### Properties of the EObject

Retrieving the values of the properties of an EObject is an unique challenge since we will have to specify, in our GraphQL schema, the type of all the potential values. Those types will have to be computed from all the datatypes supported by the various metamodels used.

We will have to support both a mono-valued and multi-valued version of all the datatypes supported starting with the default EMF datatypes.


<!-- prettier-ignore -->
```graphql
interface EObject {
  label: String!
  imageURL: String!
  eClass: EClass!
  eContents: [EObject!]!
  eContainer: EObject
  eContainingFeature: EStructuralFeature
  eContainmentFeature: EReference
  eProperties: [Property!]!
}

interface Property {
  eStructuralFeature: EStructuralFeature!
}

type StringProperty implements Property {
  eStructuralFeature: EAttribute
  value: String
}

type BooleanProperty implements Property {
  eStructuralFeature: EAttribute
  value: Boolean
}

type IntProperty implements Property {
  eStructuralFeature: EAttribute
  value: Int
}

type ReferenceProperty implements Property {
  eStructuralFeature: EReference
  value: EObject
}
```

Using this schema, one could create a query such as this one.

<!-- prettier-ignore -->
```graphql
query findEObject {
  eObject {
    label
    eProperties {
      eStructuralFeature {
        name
      }
      ... on StringProperty {
        value
      }
      ... on BooleanProperty {
        value
      }
      ... on IntProperty {
        value
      }
      ... on ReferenceProperty {
        value {
          label
        }
      }
    }
  }
}
```

Such a query could produce the following result.

<!-- prettier-ignore -->
```json
{
  "data": {
    "eObject": {
      "label": "Man - John Doe",
      "eProperties": [
        {
          "eStructuralFeature": {
            "name": "name"
          },
          "value": "John"
        },
        {
          "eStructuralFeature": {
            "name": "father"
          }
        },
        {
          "eStructuralFeature": {
            "name": "mother"
          }
        }
      ]
    }
  }
}
```